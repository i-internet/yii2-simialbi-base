<?php
/**
 * @package yii2-simialbi-base
 * @author Sandro Venetz <sandro.venetz@raiffeisen.ch
 */

namespace simialbi\yii2\widgets;

use Exception;
use kartik\select2\Select2Asset;
use Yii;
use yii\base\InvalidConfigException;
use yii\db\ActiveRecord;
use yii\di\Instance;
use yii\helpers\ArrayHelper;
use yii\helpers\Json;
use yii\helpers\Url;
use yii\web\JsExpression;

class ConditionBuilder extends InputWidget
{
    /**
     * @var string Model-class from which the attributes are fetched. Must be set on widget declaration.
     * Backslashes must be escaped: tonic\\hq\\re\\models\\AddresspoolAddress
     */
    public $modelClass = '';

    /**
     * @var array options for the query-builder. See https://querybuilder.js.org/. Only exception is the 'filter' option,
     * which is a separate property of this class: filters
     *
     * @see filters
     */
    public $pluginOptions = [];

    /**
     * @var array list of filters to show. The filters are autogenerated with the attributeLabels() of the model provided in
     * modelClass, and then merged with this property. See https://querybuilder.js.org/index.html#filters for more info.
     *
     * below is the easiest way to apply select2
     *
     * ```php
     *  'account_id' => [
     *      'plugin' => 'select2',
     *      'plugin_config' => [
     *          {{Options to pass to select2}}
     *      ]
     *  ]
     * ```
     *
     * below is the easiest way to apply select2 with ajax
     *
     * ```php
     *  'user_id' => [
     *      'plugin' => 'select2',
     *      'plugin_config' => [
     *          'ajax' => []
     *      ]
     *  ]
     * ```
     *
     * The following attributes are generated, if not provided:
     * - ajax.url
     * - aja.data       Merged with 'relations', so if you want to pass additional data to the controller, you can put it in the corresponding 'relation' attribute.
     * -
     *
     * @see relations
     */
    public $filters = [];

    /**
     * @var array relations of the modelClass with data
     *
     * Everything inside a relation will be passed to the select2 ajax->data attribute, if ajax is enabled
     *
     *
     * ```php
     *  'account_id' => [                                                           // list of fields which have a relation
     *      'class' => 'tonic\\hq\\re\\models\\Account',                            // the full classname of the relation
     *      'display' => '{clearing} - {iban{',                                     // columns to display. Columns must be between { and }, any other character will be displayed. Example: {col1} - {col2}. Mandatory
     *      'filterColumns' => ["firstname", "lastname"],                           // which columns should be searched. Mandatory and only for select2/ajax
     *      'primaryKey' => 'id',                                                   // Primary key of the database-table. Default is 'id'
     *      'filter' => [                                                           // Conditions which are always applied. See the yii\db\Query where() method
     *          'and',
     *          [
     *              'not',
     *              ['clearing' => null]
     *          ],
     *          [
     *              'not',
     *              ['iban' => null]
     *          ]
     *      ],
     *      'order' => ['firstname' => SORT_ASC, 'lastname' => SORT_ASC],           // The ordering of the related columns. See the yii\db\Query orderBy method
     *  ],
     *  ...
     * ```
     *
     */
    public $relations = [];

    /**
     * @var array columns which are available as filters. Empty array shows all
     */
    public $columns = [];

    /**
     * @var array maps types from Yii to types from queryBuilder. Keys are from Yii, values are from queryBuilder.
     */
    protected $typeMap = [
        'integer' => 'integer',
        'string' => 'string',
        'double' => 'double',
        'number' => 'double',
        'date' => 'date',
        'time' => 'time',
        'datetime' => 'datetime',
        'boolean' => 'boolean'
    ];

    /**
     * {@inheritDoc}
     * @throws InvalidConfigException
     */
    public function init(): void
    {
        if (!class_exists($this->modelClass, true)) {
            throw new InvalidConfigException('Attribute \'modelClass\' not provided');
        }

        // check if select2 is used
        foreach ($this->filters as $filter) {
            if ( ArrayHelper::getValue($filter, 'plugin') == 'select2' ) {
                // check if class kartik-v/yii2-widget-select2/select2 is loaded
                if (class_exists('kartik\select2\Select2Asset')) {
                    Select2Asset::register($this->view);
                }
                else {
                    throw new InvalidConfigException('kartik\select2\Select2Asset missing');
                }
            }
        }

        // Fix language, if not provided
        // possible values are de, en, fr
        if (!ArrayHelper::keyExists('lang_code', $this->pluginOptions)) {
            ArrayHelper::setValue($this->pluginOptions, 'lang_code', explode('-', Yii::$app->language)[0]);
        }

        parent::init();
    }

    /**
     * @inheritDoc
     * @throws InvalidConfigException
     * @throws Exception
     */
    public function run(): string
    {
        // autogenerate select2 ajax-request
        $this->checkAndCompleteSelect2Options();

        // generate filters from model
        $fields = $this->getFieldsFromModel();
        ArrayHelper::setValue($this->pluginOptions, 'filters', $fields);

        ConditionBuilderAsset::register($this->view);
        return $this->render('cb-init', [
            'id' => $this->getId(),
            'options' => Json::encode($this->pluginOptions),
            'input' => $this->renderInputHtml('hidden'),
            'inputName' => $this->name
        ]);
    }

    /**
     * Gets all the columns from the attributeLabels-Method and prepares them to be used as filters by the query-builder
     *
     * If relations have been defined, the corresponding option are shown as a dropdown.
     * These options can be filtered and ordered, as well as the columns to display can be set.
     *
     * This will NOT be done for columns searched by select2/ajax-method
     *
     * @throws InvalidConfigException
     * @throws Exception
     */
    protected function getFieldsFromModel(): array
    {
        // get attributes and labels:
        $fields = [];

        /**
         * @var ActiveRecord $model
         */
        $model = Instance::ensure($this->modelClass);
        $rules = $model->rules();

        foreach ($model->attributeLabels() as $key => $value) {

            // if columns defined, show only these
            if ($this->columns) {
                if (!in_array($key, $this->columns)) {
                    continue;
                }
            }

            $type = $this->getFieldType($key, $rules);
            $field = [
                'id' => $key,
                'field' => $key,
                'label' => $value,
                'type' => $type,
                'operators' => $this->getOperatorsByType($type, $key)
            ];

            // merge with filters defined in widget
            $field = ArrayHelper::merge($field, ArrayHelper::getValue($this->filters, $key, []));

            $fields[] = $field;
        }


        // =============================================================
        // generate options for foreign-keys
        // =============================================================
        foreach ($this->relations as $attribute => $relation) {

            $results = [];

            // only if not select2 ajax defined
            if (!ArrayHelper::getValue($this->filters, $attribute . '.plugin_config.ajax')) {

                $class = ArrayHelper::getValue($relation, 'class');
                $columnPattern = ArrayHelper::getValue($relation, 'display');
                $pk = ArrayHelper::getValue($relation, 'primaryKey', 'id');
                $filter = ArrayHelper::getValue($relation, 'filter', []);
                $order = ArrayHelper::getValue($relation, 'order', []);

                if (!$class) {
                    throw new InvalidConfigException("Parameter 'class' missing for column '$attribute'");
                }
                if (!$columnPattern) {
                    throw new InvalidConfigException("Parameter 'display' missing for column '$attribute'");
                }

                /**
                 * @var ActiveRecord $model
                 */
                $model = Instance::ensure($class);

                // get columns
                $columns = [];
                $pattern = '/\{([a-zA-Z]*)}/';
                $success = preg_match_all($pattern, $columnPattern, $columns);
                if (!$success) {
                    throw new InvalidConfigException('Error in columns for ' . $class);
                }

                $columns = $columns[1];
                $query = $model
                    ->find()
                    ->select(implode(',', $columns))
                    ->indexBy($pk);

                // add pk, if not already in array
                if (!in_array($pk, $columns)) {
                    $query->addSelect($pk);
                }

                // add filter, if available
                if ($filter) {
                    $query->where($filter);
                }

                // add order
                if ($order) {
                    $query->orderBy($order);
                }

                // get results and display as provided
                $results = $query->asArray()->all();
                foreach ($results as &$result) {
                    $keys = array_keys($result);
                    $str = $columnPattern;

                    $data = array_combine(array_map(function ($value) { return '{' . $value . '}';}, array_keys($result)), $result);
                    $str = strtr($str, $data);

                    $result = $str;
                }
                unset($result);
            }

            // Edit field
            foreach ($fields as &$field) {
                if ($field['id'] == $attribute) {
                    $field['input'] = 'select';
                    $field['values'] = $results;
                    $field['multiple'] = true;
                }
            }
            unset($field);
        }

        return $fields;
    }

    /**
     * Gets the datatype of the field out of the model-rules and maps it to a query-builder type.
     *
     * Returns 'string' as default
     *
     * @param string $field
     * @param array $rules
     * @return string
     * @throws Exception
     */
    protected function getFieldType(string $field, array $rules): string
    {
        // string as default
        $retVal = 'string';

        foreach ($rules as $rule) {

            $validator = $rule[1];

            switch ($validator) {
                case 'integer':
                case 'string':
                case 'double':
                case 'date':
                case 'time':
                case 'datetime':
                case 'boolean':
                case 'number':

                    // check if field is in array/string
                    if (is_array($rule[0])) {
                        $contains = in_array($field, $rule[0]);
                    } else {
                        $contains = $field == $rule[0];
                    }

                    if ($contains) {
                        // Returns the mapped queryBuilder-Type of a Yii-Validation-Rule.
                        // Not needed at the moment, because all types match.
                        $retVal = ArrayHelper::getValue($this->typeMap, $validator, 'string');
                    }
            }
        }
        return $retVal;
    }

    /**
     * Assign operators to data-types
     * @param $type
     * @param $attribute
     * @return array
     */
    protected function getOperatorsByType($type, $attribute): array
    {
        $retArr = [];

        switch ($type) {
            case 'integer':
                // check if attribute is a foreign-key
                if (ArrayHelper::keyExists($attribute, $this->relations)) {
                    $retArr = [
                        'equal',
                        'not_equal',
                        'is_null',
                        'is_not_null',
                        'in'
                    ];
                    break;
                }
            // NO BREAK
            case 'double':
            case 'date':
            case 'datetime':
                $retArr = [
                    'equal',
                    'not_equal',
                    'less',
                    'less_or_equal',
                    'greater',
                    'greater_or_equal',
                    'is_null',
                    'is_not_null',
                ];
                break;
            case 'string':
                $retArr = [
                    'equal',
                    'not_equal',
                    'begins_with',
                    'not_begins_with',
                    'contains',
                    'not_contains',
                    'ends_with',
                    'not_ends_with',
                    'is_empty',
                    'is_not_empty',
                    'is_null',
                    'is_not_null',
                ];
                break;
            case 'time':
            case 'boolean':
                $retArr = [
                    'equal',
                    'not_equal',
                ];
                break;
        }
        return $retArr;
    }

    /**
     * Checks the select2 pluginOptions and corrects / completes them
     *
     * @throws Exception
     */
    protected function checkAndCompleteSelect2Options()
    {
        $defaultPluginOptions = [
            'language' => explode('-', Yii::$app->language)[0]
        ];

        $defaultPluginOptionsAjax = [
            'ajax' => [
                'url' => Url::to('/condition-builder/get-options'),
                'dataType' => 'json'
            ],
            'minimumInputLength' => 3,
            'escapeMarkup' => new JsExpression('function (markup) { return markup; }'),
            'templateResult' => new JsExpression('function (item) { return item.text; }'),
            'templateSelection' => new JsExpression('function (item) { return item.text; }')
        ];

        foreach ($this->filters as $attribute => $config) {

            // if select2 plugin
            if (!ArrayHelper::getValue($config, 'plugin') == 'select2') {
                continue;
            }

            // create plugin_config, if not exists
            if (!key_exists('plugin_config', $config)) {
                $config['plugin_config'] = [];
            }

            // merge default plugin options
            $config['plugin_config'] = ArrayHelper::merge($defaultPluginOptions, $config['plugin_config']);


            // if ajax
            if ( is_array(ArrayHelper::getValue($config, 'plugin_config.ajax'))) {

                // merge default plugin options for ajax
                $config['plugin_config'] = ArrayHelper::merge($defaultPluginOptionsAjax, $config['plugin_config']);

                // generates the ajax-data attribute
                $config = $this->generateSelect2AjaxParams($attribute, $config);
            }

            ArrayHelper::setValue($this->filters, $attribute, $config);
        }
    }

    /**
     * Creates the ajax->data part of the select2 plugin
     *
     * @param string $attribute the column
     * @param array $config the configuration of the column in $attribute
     * @return array
     * @throws InvalidConfigException
     */
    protected function generateSelect2AjaxParams(string $attribute, array $config): array
    {
        // get the relation
        $relation = $this->relations[$attribute];

        // parameters class and filterColumns are mandatory!
        if (!key_exists('class', $relation) || !key_exists('filterColumns', $relation)) {
            throw new InvalidConfigException('class and filterColumns must be defined in relations, if select2-ajax is used. Filter: ' . $attribute);
        }


        $params = [
            // this is the text to search for
            'q' => new JsExpression('params.term')
        ];

        // put relation into data for ajax-request
        $params = ArrayHelper::merge($params, $relation);
        $params['class'] = str_replace('\\\\', '/', $params['class']);

        // create JavaScript Express
        $expr = new JsExpression("function (params) {return " . Json::encode($params) . "}");

        ArrayHelper::setValue($config, 'plugin_config.ajax.data', $expr);
        return $config;
    }
}
